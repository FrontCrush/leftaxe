// Generated by CoffeeScript 1.6.2
var Corridor, Dungeon, Room,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Dungeon = (function() {
  var BLANK_TILE, CORRIDOR_TILE, DOOR_TILE, FLOOR_TILE, WALL_TILE;

  BLANK_TILE = 0;

  FLOOR_TILE = 1;

  WALL_TILE = 2;

  DOOR_TILE = 3;

  CORRIDOR_TILE = 4;

  Dungeon.prototype.random = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  Dungeon.prototype.distance = function(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));
  };

  Dungeon.prototype.collides = function(x, y, distance) {
    var caller;

    caller = this;
    return _.some(this.entities, function(entity) {
      return caller.distance(x, y, entity.x, entity.y) < distance;
    });
  };

  Dungeon.prototype.collision_map = function() {
    return _.map(this.tiles, function(row) {
      return _.map(row, function(tile) {
        if (tile === WALL_TILE) {
          return FLOOR_TILE;
        } else {
          return BLANK_TILE;
        }
      });
    });
  };

  Dungeon.prototype.collisionMap = function() {
    var map;

    map = {};
    _.each(this.tiles, function(row, yIndex) {
      return _.each(row, function(tile, xIndex) {
        var key;

        key = x + ',' + y;
        if (tile === WALL_TILE) {
          return map[key] = FLOOR_TILE;
        } else {
          return map[key] = BLANK_TILE;
        }
      });
    });
    return map;
  };

  Dungeon.prototype.background_map = function() {
    return _.map(this.tiles, function(row) {
      return _.map(row, function(tile) {
        if (tile === WALL_TILE) {
          return BLANK_TILE;
        } else if (tile === DOOR_TILE) {
          return FLOOR_TILE;
        } else {
          return tile;
        }
      });
    });
  };

  function Dungeon(map_width, map_height, max_features, room_chance) {
    var counting_tries, dir, east_tile, feature, newx, newy, north_tile, pos, south_tile, state, testing, valid_tile, ways, west_tile, x, xmod, y, ymod;

    this.map_width = map_width;
    this.map_height = map_height;
    this.max_features = max_features;
    this.room_chance = room_chance;
    this.tiles = [];
    this.current_features = 0;
    this.fill_map();
    this.up_stairs_pos = {
      x: 0,
      y: 0
    };
    this.down_stairs_pos = {
      x: 0,
      y: 0
    };
    this.monsters = [];
    this.entities = [];
    x = Math.floor(this.map_width / 2);
    y = Math.floor(this.map_height / 2);
    dir = this.random(0, 3);
    this.make_room(x, y, 8, 8, dir);
    this.current_features += 1;
    counting_tries = 0;
    while (counting_tries < 1000) {
      if (this.current_features === this.max_features) {
        break;
      }
      newx = 0;
      xmod = 0;
      newy = 0;
      ymod = 0;
      valid_tile = -1;
      testing = 0;
      while (testing < 1000) {
        newx = this.random(1, this.map_width - 2);
        newy = this.random(1, this.map_height - 2);
        valid_tile = -1;
        if (this.get_tile(newx, newy) === WALL_TILE || this.get_tile(newx, newy) === CORRIDOR_TILE) {
          if (this.get_tile(newx, newy + 1) === FLOOR_TILE || this.get_tile(newx, newy + 1) === CORRIDOR_TILE) {
            valid_tile = 0;
            xmod = 0;
            ymod = -1;
          } else if (this.get_tile(newx - 1, newy) === FLOOR_TILE || this.get_tile(newx - 1, newy) === CORRIDOR_TILE) {
            valid_tile = 1;
            xmod = 1;
            ymod = 0;
          } else if (this.get_tile(newx, newy - 1) === FLOOR_TILE || this.get_tile(newx, newy - 1) === CORRIDOR_TILE) {
            valid_tile = 2;
            xmod = 0;
            ymod = 1;
          } else if (this.get_tile(newx + 1, newy) === FLOOR_TILE || this.get_tile(newx + 1, newy) === CORRIDOR_TILE) {
            valid_tile = 3;
            xmod = -1;
            ymod = 0;
          }
          if (valid_tile > -1) {
            if (this.get_tile(newx, newy) === DOOR_TILE) {
              valid_tile = -1;
            } else if (this.get_tile(newx - 1, newy) === DOOR_TILE) {
              valid_tile = -1;
            } else if (this.get_tile(newx, newy - 1) === DOOR_TILE) {
              valid_tile = -1;
            } else if (this.get_tile(newx + 1, newy) === DOOR_TILE) {
              valid_tile = -1;
            }
          }
          if (valid_tile > -1) {
            break;
          }
        }
        testing += 1;
      }
      if (valid_tile > -1) {
        feature = this.random(0, 100);
        if (feature <= this.room_chance) {
          if (this.make_room(newx + xmod, newy + ymod, 8, 8, valid_tile)) {
            this.current_features += 1;
            this.set_tile(newx, newy, DOOR_TILE);
            this.set_tile(newx + xmod, newy + ymod, FLOOR_TILE);
          }
        } else if (feature >= this.room_chance) {
          if (this.make_corridor(newx + xmod, newy + ymod, 6, valid_tile)) {
            this.current_features += 1;
            this.set_tile(newx, newy, DOOR_TILE);
            this.set_tile(newx + xmod, newy + ymod, FLOOR_TILE);
          }
        }
      }
      counting_tries += 1;
    }
    newx = 0;
    newy = 0;
    ways = 0;
    state = 0;
    while (state !== 10) {
      testing = 0;
      while (testing < 1000) {
        newx = this.random(1, this.map_width - 1);
        newy = this.random(1, this.map_height - 2);
        ways = 4;
        north_tile = this.get_tile(newx, newy + 1);
        east_tile = this.get_tile(newx - 1, newy);
        south_tile = this.get_tile(newx, newy - 1);
        west_tile = this.get_tile(newx + 1, newy);
        if (north_tile === FLOOR_TILE) {
          ways -= 1;
        }
        if (east_tile === FLOOR_TILE) {
          ways -= 1;
        }
        if (south_tile === FLOOR_TILE) {
          ways -= 1;
        }
        if (west_tile === FLOOR_TILE) {
          ways -= 1;
        }
        pos = {
          x: newx,
          y: newy
        };
        if (state === 0 && ways === 0 && !this.collides(newx, newy, 2)) {
          this.up_stairs_pos.x = newx;
          this.up_stairs_pos.y = newy;
          this.entities.push(pos);
          state = 1;
          break;
        } else if (state === 1 && ways === 0 && this.distance(this.up_stairs_pos.x, this.up_stairs_pos.y, newx, newy) > 2 && !this.collides(newx, newy, 2)) {
          this.down_stairs_pos.x = newx;
          this.down_stairs_pos.y = newy;
          this.entities.push(pos);
          state = 2;
          break;
        } else if (state === 2 && ways === 0 && !this.collides(newx, newy, 3)) {
          this.monsters.push(pos);
          this.entities.push(pos);
          if (this.monsters.length > 10) {
            state = 10;
          }
        }
        testing += 1;
      }
    }
  }

  Dungeon.prototype.fill_map = function() {
    var row, x, y, _i, _j, _ref, _ref1, _results;

    _results = [];
    for (y = _i = 1, _ref = this.map_height; 1 <= _ref ? _i <= _ref : _i >= _ref; y = 1 <= _ref ? ++_i : --_i) {
      row = [];
      for (x = _j = 1, _ref1 = this.map_width; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 1 <= _ref1 ? ++_j : --_j) {
        row.push(BLANK_TILE);
      }
      _results.push(this.tiles.push(row));
    }
    return _results;
  };

  Dungeon.prototype.make_room = function(x, y, width, height, direction) {
    var room;

    room = new Room(x, y, width, height, direction, this);
    return room.build();
  };

  Dungeon.prototype.make_corridor = function(x, y, length, direction) {
    var corridor;

    corridor = new Corridor(x, y, length, direction, this);
    return corridor.build();
  };

  Dungeon.prototype.get_tile = function(x, y) {
    return this.tiles[y][x];
  };

  Dungeon.prototype.set_tile = function(x, y, tile) {
    return this.tiles[y][x] = tile;
  };

  Dungeon.prototype.is_blank_tile = function(x, y) {
    return this.get_tile(x, y) === BLANK_TILE;
  };

  Dungeon.prototype.set_wall_tile = function(x, y) {
    return this.set_tile(x, y, WALL_TILE);
  };

  Dungeon.prototype.set_floor_tile = function(x, y) {
    return this.set_tile(x, y, FLOOR_TILE);
  };

  return Dungeon;

})();

Room = (function() {
  function Room(x, y, width, height, direction, dungeon) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.direction = direction;
    this.dungeon = dungeon;
    this.xlen = this.dungeon.random(4, this.width);
    this.ylen = this.dungeon.random(4, this.height);
    this.dir = 0;
    if (this.direction > 0 && this.direction < 4) {
      this.dir = this.direction;
    }
  }

  Room.prototype.build = function() {
    if (this.dir === 0 && this.has_enough_space_north()) {
      return this.build_north();
    } else if (this.dir === 1 && this.has_enough_space_east()) {
      return this.build_east();
    } else if (this.dir === 2 && this.has_enough_space_south()) {
      return this.build_south();
    } else if (this.dir === 3 && this.has_enough_space_west()) {
      return this.build_west();
    } else {
      return false;
    }
  };

  Room.prototype.has_enough_space_north = function() {
    var xtemp, ytemp;

    ytemp = this.y;
    while (ytemp > (this.y - this.ylen)) {
      if (ytemp < 0 || ytemp >= this.dungeon.map_height) {
        return false;
      }
      xtemp = this.x - Math.floor(this.xlen / 2);
      while (xtemp < (this.x + Math.floor((this.xlen + 1) / 2))) {
        if (xtemp < 0 || xtemp >= this.dungeon.map_width) {
          return false;
        }
        if (!this.dungeon.is_blank_tile(xtemp, ytemp)) {
          return false;
        }
        xtemp += 1;
      }
      ytemp -= 1;
    }
    return true;
  };

  Room.prototype.build_north = function() {
    var xtemp, ytemp, _results;

    ytemp = this.y;
    _results = [];
    while (ytemp > (this.y - this.ylen)) {
      xtemp = this.x - Math.floor(this.xlen / 2);
      while (xtemp < (this.x + Math.floor((this.xlen + 1) / 2))) {
        if (xtemp === (this.x - Math.floor(this.xlen / 2))) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (xtemp === (this.x + Math.floor((this.xlen - 1) / 2))) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (ytemp === this.y) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (ytemp === (this.y - this.ylen + 1)) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else {
          this.dungeon.set_floor_tile(xtemp, ytemp);
        }
        xtemp += 1;
      }
      _results.push(ytemp -= 1);
    }
    return _results;
  };

  Room.prototype.has_enough_space_east = function() {
    var xtemp, ytemp;

    ytemp = this.y - Math.floor(this.ylen / 2);
    while (ytemp < (this.y + Math.floor((this.ylen + 1) / 2))) {
      if (ytemp < 0 || ytemp >= this.dungeon.map_height) {
        return false;
      }
      xtemp = this.x;
      while (xtemp < this.x + this.xlen) {
        if (xtemp < 0 || xtemp >= this.dungeon.map_width) {
          return false;
        }
        if (!this.dungeon.is_blank_tile(xtemp, ytemp)) {
          return false;
        }
        xtemp += 1;
      }
      ytemp += 1;
    }
    return true;
  };

  Room.prototype.build_east = function() {
    var xtemp, ytemp, _results;

    ytemp = this.y - Math.floor(this.ylen / 2);
    _results = [];
    while (ytemp < (this.y + Math.floor((this.ylen + 1) / 2))) {
      xtemp = this.x;
      while (xtemp < this.x + this.xlen) {
        if (xtemp === this.x) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (xtemp === this.x + this.xlen - 1) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (ytemp === this.y - Math.floor(this.ylen / 2)) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (ytemp === this.y + Math.floor((this.ylen - 1) / 2)) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else {
          this.dungeon.set_floor_tile(xtemp, ytemp);
        }
        xtemp += 1;
      }
      _results.push(ytemp += 1);
    }
    return _results;
  };

  Room.prototype.has_enough_space_south = function() {
    var xtemp, ytemp;

    ytemp = this.y;
    while (ytemp < this.y + this.ylen) {
      if (ytemp < 0 || ytemp >= this.dungeon.map_height) {
        return false;
      }
      xtemp = this.x - Math.floor(this.xlen / 2);
      while (xtemp < this.x + Math.floor((this.xlen + 1) / 2)) {
        if (xtemp < 0 || xtemp >= this.dungeon.map_width) {
          return false;
        }
        if (!this.dungeon.is_blank_tile(xtemp, ytemp)) {
          return false;
        }
        xtemp += 1;
      }
      ytemp += 1;
    }
    return true;
  };

  Room.prototype.build_south = function() {
    var xtemp, ytemp;

    ytemp = this.y;
    while (ytemp < this.y + this.ylen) {
      xtemp = this.x - Math.floor(this.xlen / 2);
      while (xtemp < this.x + Math.floor((this.xlen + 1) / 2)) {
        if (xtemp === this.x - Math.floor(this.xlen / 2)) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (xtemp === this.x + Math.floor((this.xlen - 1) / 2)) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (ytemp === this.y) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (ytemp === this.y + this.ylen - 1) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else {
          this.dungeon.set_floor_tile(xtemp, ytemp);
        }
        xtemp += 1;
      }
      ytemp += 1;
    }
    return true;
  };

  Room.prototype.has_enough_space_west = function() {
    var xtemp, ytemp;

    ytemp = this.y - Math.floor(this.ylen / 2);
    while (ytemp < this.y + Math.floor((this.ylen + 1) / 2)) {
      if (ytemp < 0 || ytemp >= this.dungeon.map_height) {
        return false;
      }
      xtemp = this.x;
      while (xtemp > this.x - this.xlen) {
        if (xtemp < 0 || xtemp >= this.dungeon.map_width) {
          return false;
        }
        if (!this.dungeon.is_blank_tile(xtemp, ytemp)) {
          return false;
        }
        xtemp -= 1;
      }
      ytemp += 1;
    }
    return true;
  };

  Room.prototype.build_west = function() {
    var xtemp, ytemp, _results;

    ytemp = this.y - Math.floor(this.ylen / 2);
    _results = [];
    while (ytemp < this.y + Math.floor((this.ylen + 1) / 2)) {
      xtemp = this.x;
      while (xtemp > this.x - this.xlen) {
        if (xtemp === this.x) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (xtemp === this.x - this.xlen + 1) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (ytemp === this.y - Math.floor(this.ylen / 2)) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else if (ytemp === this.y + Math.floor((this.ylen - 1) / 2)) {
          this.dungeon.set_wall_tile(xtemp, ytemp);
        } else {
          this.dungeon.set_floor_tile(xtemp, ytemp);
        }
        xtemp -= 1;
      }
      _results.push(ytemp += 1);
    }
    return _results;
  };

  return Room;

})();

Corridor = (function(_super) {
  __extends(Corridor, _super);

  function Corridor(x, y, length, direction, dungeon) {
    var horizontal;

    this.x = x;
    this.y = y;
    this.length = length;
    this.direction = direction;
    this.dungeon = dungeon;
    horizontal = this.dungeon.random(0, 1);
    if (horizontal) {
      this.xlen = this.dungeon.random(3, this.length);
      this.ylen = 3;
    } else {
      this.xlen = 3;
      this.ylen = this.dungeon.random(3, this.length);
    }
    this.dir = 0;
    if (this.direction > 0 && this.direction < 4) {
      this.dir = this.direction;
    }
  }

  return Corridor;

})(Room);
